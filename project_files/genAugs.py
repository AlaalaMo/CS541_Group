# -*- coding: utf-8 -*-
"""genAugs.ipynb

Automatically generated by Colaboratory.

"""

import numpy as np
import matplotlib.pyplot as plt

import cv2
import os
import itertools

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.models as models
from torchvision import transforms
import torchsummary
import copy


device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

torch.manual_seed(42)

# Get sample image from Google Drive and load it for debugging. Will need to
# modify code to deal with mini-batch of RGB image.
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

rootDir = "/content/drive/My Drive/data"
os.chdir(rootDir)

img = cv2.imread("airport_001.jpg")
imgMod = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.imshow(img)
plt.show()

# Convert image to float and normalize.
imgMod = imgMod.astype('float')
imgMod = imgMod / 255.0


plt.imshow(imgMod)
plt.show()

# Convert to expected format (band, height, width).
imgMod = np.moveaxis(imgMod, 2, 0)


class addGaussianNoise(object):
    # Transform to add gaussian noise since PyTorch did not have one (that I know of).
    def __init__(self, mean=0.0, std=1.0, p=0.5):
        self.mean = mean
        self.std = std
        self.p = p
      
    def __call__(self, img):
        if torch.rand(1).item() < self.p:
            return img + torch.randn(img.size()) * self.std + self.mean
        return img
        
    def __repr__(self):
        return self.__class__.__name__ + '(mean={0}, std={1}, p={2})'.format(self.mean, self.std, self.p)


# Create full-factorial combination of the augmentations. Each
# one will be a "task." Each augmentation will only have 2 levels (on and off).
# Hence, there will be 512 tasks if there are 9 augs with 2 levels each.

# First, set number of augmentations per task.
numAugs = 9
augTasks = list(itertools.product([0, 1], repeat=numAugs))


def composeAugs(pHF, pVF, rotAng, pPersp, cropScale, pNoise, satVal, brightVal, contrastVal, blurSigma):

    # Function to compose the augmentations, the order of which will be fixed.
    # Some of these parameters are best guess and can be changed if we need to.
    # For example, hue is set to have very very minor change because it can 
    # create false colors (green grass can become magenta). If the team decides
    # that false colors are acceptable, we can change the hue parameter.
    
    # Scripting the transformations will not work here due to the inclusion of
    # addGaussianNoise transform. Use transform composition instead.
    imXforms = transforms.Compose([
        transforms.RandomHorizontalFlip(p=pHF),
        transforms.RandomVerticalFlip(p=pVF),
        transforms.RandomRotation(rotAng, fill=0.5),
        transforms.RandomPerspective(distortion_scale=0.1, p=pPersp, fill=0.5),
        transforms.RandomResizedCrop(256,
                                    scale=(cropScale, 1.0),
                                    ratio=(1.0, 1.0),
                                    interpolation=transforms.InterpolationMode.BILINEAR),
        addGaussianNoise(std=0.1, p=pNoise),
        transforms.ColorJitter(saturation=satVal, hue=0.01),
        transforms.ColorJitter(brightness=brightVal, contrast=contrastVal),
        transforms.GaussianBlur(9, sigma=blurSigma)
        ])
    
    return imXforms


def makeAugs(taskList, imgTens):
    
    # Loop through each task to create each augmented image. The result should be
    # a tensor containing a mini-batch of augmented images for each task (will be
    # a huge number). So, if the input is a mini-batch of 28 images and there are
    # 512 tasks, then the tensor should be something along the line of
    # (28, 512, 3, 256, 256). This code currently only outputs the augmented image
    # from the last task. Need to be modified.
    
    # taskList = (taskList[102:104])	# For testing.
    
    for task in taskList:
        # Set parameters for each of the augs as appropriate (0/1).
        pHF = 0.99 if task[0] == 1 else 0.0
        pVF = 0.99 if task[1] == 1 else 0.0
        rotAng = 359.0 if task[2] == 1 else 0.0
        pPersp = 0.99 if task[3] == 1 else 0.0
        cropScale = 0.5 if task[4] == 1 else 1.0
        pNoise = 0.99 if task[5] == 1 else 0.0
        satVal = 4.0 if task[6] == 1 else 0.0
        brightVal = 0.5 if task[7] == 1 else 0.0
        contrastVal = 0.9 if task[7] == 1 else 0.0
        blurSigma = (0.01, 2.0) if task[8] == 1 else 1e-9

        augXforms = composeAugs(pHF, pVF, rotAng, pPersp, cropScale, pNoise, 
                                satVal, brightVal, contrastVal, blurSigma)
        
        augsFin = augXforms(torch.from_numpy(imgTens))

    return augsFin


# Debug and test/visualize results.
test = makeAugs(augTasks, imgMod)

# Convert back to numpy for plotting.
testForPlot = test.numpy()
testForPlot = np.moveaxis(testForPlot, 0, -1)

plt.imshow(testForPlot)
plt.show()
